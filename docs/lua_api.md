# Lua API (контракт C++ ↔ Lua)

**Проект:** `snake`  
**Среда:** Windows, C++20 + SDL2 + Lua 5.4 (`lua54.dll` рядом с `snake.exe`)  
**Цель документа:** зафиксировать интерфейс между C++-движком и Lua-скриптами: пути, загрузку, хук-и, форматы данных, контракт правил.

> Статус: **Draft (no-guess)** — документ содержит только зафиксированные требования. Всё, что касается `rules.lua`, закреплено в разделе «Rules contract (assets/scripts/rules.lua)» и является единым источником правды.

---

## 1) Расположение скриптов и файлов

### 1.1 Репозиторий / assets
- `assets/scripts/rules.lua` — правила, формулы, политика спавна, реакции
- `assets/scripts/config.lua` — дефолтный конфиг, копируется в AppData при первом запуске

### 1.2 Пользовательские данные (AppData)
- `%AppData%/snake/config.lua` — активный конфиг (редактируется UI в игре)
- `%AppData%/snake/highscores.json` — рекорды (JSON, не Lua)

### 1.3 Порядок загрузки (старт приложения)
1) Убедиться, что `%AppData%/snake/` существует.
2) Если `%AppData%/snake/config.lua` отсутствует → копировать из `assets/scripts/config.lua`.
3) Инициализировать SDL + окно/рендерер (все объекты UI остаются на стороне C++).
4) Создать новое состояние Lua и загрузить скрипты.
5) Загрузить **пользовательский конфиг**: `%AppData%/snake/config.lua`.
6) Загрузить **правила**: `assets/scripts/rules.lua`.
7) Вызвать хук `on_app_init(ctx)` (если определён).
8) Стартовать первый раунд → вызвать `on_round_start(ctx)` (если определён).

### 1.4 Хот-релоад (F5)
- Триггер: **F5** (работает в меню, во время игры, на паузе, на экране GameOver).
- Алгоритм:
  1) Создать *новое* состояние Lua.
  2) Загрузить `%AppData%/snake/config.lua`.
  3) Загрузить `assets/scripts/rules.lua`.
  4) Если всё успешно → подменить активное состояние.
  5) Если ошибка → оставить старое состояние и показать ошибку пользователю.

---

## 2) Контекст `ctx`
Движок передаёт в Lua таблицу `ctx` на каждый вызов хука.

```lua
ctx = {
  -- неизменяемые поля на время вызова
  phase = "menu" | "playing" | "paused" | "gameover",
  dt = number,              -- дельта времени рендера в секундах
  now = number,             -- монотонное время с запуска приложения, сек

  -- снапшот конфига (%AppData%/snake/config.lua)
  config = {
    board_w = integer,      -- дефолт 20
    board_h = integer,      -- дефолт 20
    tile_size = integer,    -- дефолт 32
    window_w = integer,     -- дефолт 800
    window_h = integer,     -- дефолт 800
    fullscreen = boolean,   -- borderless fullscreen desktop
    vsync = boolean,

    grid = {
      wrap_mode = boolean,  -- стенки (false) или зацикливание (true)
    },

    ui_panel_mode = "auto" | "top" | "right",

    audio = {
      master = number,      -- 0..1
      sfx = number,         -- 0..1
      music = number,       -- 0..1 (резерв)
    },

    keybinds = { },         -- схема пока открытая
  },

  -- снапшот игрового состояния
  score = integer,

  board = { w = integer, h = integer },

  snake = {
    dir = "up" | "down" | "left" | "right",
    length = integer,
    body = {
      {x=integer,y=integer}, -- массив позиций, голова = body[1]
      -- ...
    },
  },

  food = { pos = { x=integer, y=integer } },

  bonuses = {
    { type="bonus_score", pos={x=integer,y=integer} },
    { type="bonus_slow",  pos={x=integer,y=integer} },
  },

  effects = {
    slow = {
      active = boolean,
      multiplier = 0.70,     -- фиксированный множитель
      remaining = number,    -- секунды (0, если не активно)
    }
  },

  -- полезная нагрузка события (только для event-хуков; иначе nil)
  event = nil,
}
```

### 2.1 Базовые типы
- **Позиция**: `{ x = 0, y = 0 }` — целочисленные координаты клеток (0-based).
- **Направление**: строки `"up" | "down" | "left" | "right"`.
- **Тип бонуса**: строки `"bonus_score" | "bonus_slow"`.
- **Timestamp**: ISO-8601 UTC, например `"2026-01-05T18:55:00Z"` (создаются на C++ стороне при сохранении рекордов).

---

## 3) Гарантии движка (C++)
Эти правила **жёстко применяются** в C++ вне зависимости от Lua:
- Еда на поле: всегда **ровно 1**.
- Бонусы на поле: **не более 2**, типы только `bonus_score`, `bonus_slow`.
- Спавн еды/бонусов **никогда** не попадает на тело змейки.
- Рост змейки:
  - Еда: длина +1.
  - `bonus_score` и `bonus_slow` **не** растят змейку.
- `bonus_score` добавляет **+50** сразу (если Lua не переопределит сумму через контракт правил, движок всё равно применит возвращаемое значение `pickup_effect`).
- `bonus_slow`:
  - множитель скорости: **×0.70** (значение берётся из `config.gameplay.slow_multiplier`, дефолт 0.70);
  - длительность: **6 секунд** (значение из `config.gameplay.slow_duration_sec`, дефолт 6.0);
  - стак: **только продление времени**, множитель не накапливается.
- Бонусы **не исчезают** со временем — лежат, пока не взяты.
- Коллизии:
  - самоукус → **GameOver**;
  - со стеной → поведение зависит от `config.grid.wrap_mode` или логики `resolve_wall` (см. контракт правил).

---

## 4) Lua Hooks (events)
Все хуки задаются **глобальными функциями** в `rules.lua` (не в таблицах/модулях). Любой отсутствующий хук пропускается тихо (no-op). Если хук существует, но завершился ошибкой, движок логирует ошибку, продолжает работу с предыдущим состоянием/правилами (никаких частичных применений) и не падает.

### 4.1 Глобальные функции
1. **`on_app_init(ctx)`**
   - Вызывается **один раз** после инициализации приложения и Lua-состояния: SDL, окно и рендерер уже есть, конфиг загружен, скрипты загружены.
   - Срабатывает **до** первой партии/раунда.
   - Назначение: инициализация Lua-состояния (статистика, seed, кеши). UI остаётся на стороне C++.

2. **`on_round_start(ctx)`**
   - Вызывается при старте каждой партии **и при самом первом запуске игры**.
   - Перед вызовом раунд сброшен к дефолтам: длина змейки = 3, счёт = 0, таймеры обнулены, поле очищено, еда уже заспавнена.
   - Использование: статистика, телеметрия, сброс Lua-состояния.

3. **`on_tick_begin(ctx)`**
   - Вызывается в начале **каждого** фиксированного игрового тика, **до** перемещения, коллизий и применения эффектов.
   - Использование: пролог тика, измерения, отладка.

4. **`on_tick_end(ctx)`**
   - Вызывается в конце **каждого** фиксированного игрового тика, **после** перемещения, коллизий, спавна, поедания и применения эффектов за тик.
   - Вызывается **только** если тик завершился в состоянии `Playing` (или Paused, если тик шёл на паузе); если в середине тика наступил GameOver, `on_tick_end` **не** вызывается.
   - Использование: эпилог тика, метрики, отладка.

5. **`on_food_eaten(ctx)`**
   - Нотификация о поедании еды.
   - Движок уже применил результат `pickup_effect("food", config)`: изменён счёт, увеличена длина, еда сразу респавнена (на поле снова **ровно 1** еда).
   - Использование: телеметрия, визуальные/звуковые сигналы (аудио всё равно в C++).

6. **`on_bonus_picked(ctx, type)`**
   - Нотификация о подборе бонуса.
   - `type` — строка **строго** из набора `"bonus_score"` или `"bonus_slow"` (`"food"` сюда никогда не приходит).
   - Вызывается **после** применения `pickup_effect` для бонуса:
     - `bonus_score`: +50 к счёту немедленно, без роста.
     - `bonus_slow`: продление таймера замедления на +6 сек, множитель фиксирован 0.70, стак — только по времени.
   - Бонусы не исчезают по таймеру; на поле их максимум 2 (контролируется C++).
   - Использование: телеметрия, визуальные/звуковые сигналы, статистика.

7. **`on_game_over(ctx, reason)`**
   - Вызывается один раз при переходе в состояние GameOver.
   - `reason` — строка из набора `"self_collision" | "wall_collision" | "quit" | "unknown"`.
   - Использование: логирование, телеметрия, Lua-статистика.

8. **`on_setting_changed(ctx, key, value)`**
   - Вызывается немедленно при изменении настройки в UI (без отложенных применений).
   - `key` — строковый путь, например `grid.wrap_mode`, `window.vsync`, `window.width`, `ui.panel_mode`.
   - `value` передаётся в нативном виде Lua (boolean/number/string/table).
   - Вызывается **после** того, как `config.lua` обновлён и движок применил изменение (где применимо).

> Логика правил (скорость, столкновения, эффекты) по-прежнему определяется функциями `pickup_effect`, `resolve_wall`, `speed_ticks_per_sec`, `want_spawn_bonus` в `rules.lua` и жёстко применяется C++ движком. Хуки — это уведомления/сбор состояния; они **не** могут нарушить инварианты движка.

### 4.2 Порядок вызовов
**Старт приложения:**
1) Загрузить `config.lua` из `%AppData%/snake/` (при отсутствии — скопировать дефолт).  
2) Инициализировать SDL + окно/рендерер.  
3) Создать LuaRuntime и загрузить скрипты.  
4) Вызвать `on_app_init(ctx)`, если определена.  
5) Запустить первый раунд → вызвать `on_round_start(ctx)`, если определена.

**Один игровой тик (fixed update):**
1) `on_tick_begin(ctx)`, если определена.  
2) Тик движка: расчёт следующей клетки головы, обработка стен, движение, самоколлизии, обработка подбора, спавн политики, обновление эффектов.  
3) Нотификации, если событие произошло в этом тике: `on_food_eaten` / `on_bonus_picked`.  
4) Если наступил GameOver → вызвать `on_game_over(ctx, reason)`.  
5) `on_tick_end(ctx)`, если определена и раунд всё ещё в состоянии Playing (не вызывается, если в середине тика переключились в GameOver).

### 4.3 Контракт хот-релоада Lua (F5)
- **Триггер:** клавиша **F5** (работает в меню, во время игры, на паузе и на экране GameOver). Перезапуск приложения не происходит — обновляются только Lua-правила.
- **Целевые файлы:** обязательно `assets/scripts/rules.lua`; `menu.lua` может быть добавлен позже, но сейчас область хот-релоада = `rules.lua`.
- **Атомарность:** перезагрузка выполняется в **новом** временном `lua_State` (или аналогичном транзакционном контексте). Текущая рабочая Lua остаётся нетронутой, пока новый экземпляр не пройдет все проверки.
- **Валидировать при успешной загрузке (обязательно):**
  - `rules.lua` загружен без синтаксических/рантайм ошибок.
  - Все обязательные глобальные функции правил существуют: `speed_ticks_per_sec`, `resolve_wall`, `pickup_effect`, `want_spawn_bonus` (хуки из §4 могут отсутствовать — это допустимо).
- **Обработка ошибок (любая ошибка на любом этапе):**
  - остаёмся на **предыдущем** рабочем состоянии и правилах, никаких частичных подмен;
  - ошибка логируется;
  - в UI/оверлее показывается текст вида `Lua reload error: <сообщение> [file:line если доступно]`, который остаётся видимым **до следующей успешной перезагрузки** или явного сброса пользователем (если такая UX предусмотрена).
- **Успешный хот-релоад:**
  - мгновенно переключаемся на новый `lua_State` с обновлёнными правилами;
  - оверлей с предыдущей ошибкой очищается (или кратко показывается успех — опционально);
  - игра продолжает работу без сброса/перезапуска.
- **Устойчивость:** хот-релоад безопасен во время геймплея; даже при битых скриптах приложение не должно падать.

---

## 5) Rules contract (`assets/scripts/rules.lua`)
Этот раздел — **единый источник правды** для контракта правил. Всё, что описано ниже, обязательно для `rules.lua` и уже подкреплено проверками на C++ стороне.

### 5.1 Общие принципы
- Скрипты правил загружаются из `./assets/scripts/` рядом с исполняемым файлом.
- Конфиг всегда читается из `%AppData%/snake/config.lua` и передаётся в Lua как `config` (см. `ctx.config`).
- Все функции правил должны быть **глобальными**, никаких возвращаемых таблиц не используется.
- Движок вызывает Lua; Lua не управляет UI или циклом игры самостоятельно.

### 5.2 Обязательные глобальные функции правил
`rules.lua` обязан определить следующие функции (их отсутствие считается ошибкой загрузки):

1. **`speed_ticks_per_sec(score, config) -> number`**
   - **Вход:** `score` (integer, текущий счёт), `config` (таблица из `%AppData%/snake/config.lua`).
   - **Выход:** `ticks_per_sec` (`number > 0`).
   - **Семантика:** задаёт базовую скорость тиков (шагов в секунду) **до** применения эффекта замедления. Движок сам умножает результат на `slow_multiplier`, когда активен эффект замедления.

2. **`resolve_wall(x, y, board_w, board_h, wrap_mode) -> (alive:boolean, nx:integer, ny:integer)`**
   - **Вход:** `x`, `y` — предполагаемая следующая клетка головы; `board_w`, `board_h` — размеры поля; `wrap_mode` — булев флаг `config.grid.wrap_mode`.
   - **Выход:**
     - `alive=false` → столкновение со стеной, наступает GameOver.
     - `alive=true` → ход разрешён, координаты скорректированы до `(nx, ny)`.
   - **Поведение по умолчанию:**
     - если `wrap_mode == true`: возвратить `alive=true` и обернуть координаты (`nx = (x % board_w + board_w) % board_w`, аналогично для `y`);
     - иначе: если выход за границы → `alive=false`; если внутри поля → `alive=true` с теми же координатами.

3. **`pickup_effect(kind, config) -> table`**
   - **Вход:** `kind` — строка `"food" | "bonus_score" | "bonus_slow"`; `config` — таблица конфига.
   - **Выход:** таблица со всеми полями (каждое поле обязательно):
     - `score_delta` (integer)
     - `grow` (boolean)
     - `slow_add_sec` (number, 0 если эффекта нет)
   - **Фиксированные правила:**
     - `food`: `score_delta = config.gameplay.food_score` (дефолт 10), `grow = true`, `slow_add_sec = 0`.
     - `bonus_score`: `score_delta = 50` (или `config.gameplay.bonus_score_score`, если поле есть), `grow = false`, `slow_add_sec = 0`.
     - `bonus_slow`: `score_delta = 0`, `grow = false`, `slow_add_sec = config.gameplay.slow_duration_sec` (дефолт 6.0).
   - **Поведение движка:** применяет `score_delta`, увеличивает длину, если `grow == true`, и продлевает таймер замедления на `slow_add_sec`, если он больше нуля. Сам множитель замедления всегда берётся из `config.gameplay.slow_multiplier` (дефолт 0.70); множители не накапливаются, удлиняется только время.

4. **`want_spawn_bonus(score, config, bonuses_count) -> (bonus_type | nil)`**
   - **Вход:** `score` (integer), `config` (таблица), `bonuses_count` (integer, текущее количество бонусов на поле).
   - **Выход:** `nil` → не спавнить бонус; `"bonus_score"` или `"bonus_slow"` → запросить спавн указанного типа.
   - **Гарантии со стороны C++:** на поле всегда **ровно 1** еда; бонусов **не более 2**; бонусы никогда не появляются на змейке; бонусы не исчезают по времени. Lua решает только политику/вероятности и тип бонуса, когда движок запрашивает спавн.

### 5.3 Дополнительные замечания
- Эффект замедления всегда задаётся движком множителем `config.gameplay.slow_multiplier` и длительностью, которая складывается по времени (`slow_add_sec`).
- Поле `wrap_mode` приходит из `config.grid.wrap_mode` (в конфиге опция хранится в `config.grid`, но в контексте `resolve_wall` передаётся отдельным аргументом для удобства).
- Все хуки из §4 и функции из этого раздела — глобальные; никаких таблиц `return` не используется.

---

## 6) Обработка ошибок (Lua)
- Любая ошибка Lua должна превращаться в читаемую строку.
- Ошибка при хот-релоаде: движок сохраняет старое состояние и показывает сообщение.
- Ошибка в хуке/во время тика: движок логирует/показывает ошибку, продолжает работу с **предыдущим** состоянием/правилами (никаких частичных применений) и не падает.

---

## 7) Замечания по производительности
- Хуки должны быть быстрыми; избегайте тяжёлых аллокаций на каждый тик.
- Предпочитайте предвычисления и константные таблицы.
- Не загружайте файлы в `on_tick_begin/on_tick_end`; используйте `on_app_init` и хот-релоад.

---

## 8) Пример каркаса `rules.lua`

```lua
-- rules.lua (каркас, все функции глобальные)

function on_app_init(ctx) end
function on_round_start(ctx) end
function on_tick_begin(ctx) end
function on_tick_end(ctx) end
function on_food_eaten(ctx) end
function on_bonus_picked(ctx, bonus_type) end
function on_game_over(ctx, reason) end
function on_setting_changed(ctx, key, value) end

function speed_ticks_per_sec(score, config)
  return 10.0 + score * 0.05 -- пример
end

function resolve_wall(x, y, board_w, board_h, wrap_mode)
  if wrap_mode then
    local nx = (x % board_w + board_w) % board_w
    local ny = (y % board_h + board_h) % board_h
    return true, nx, ny
  end
  if x < 0 or x >= board_w or y < 0 or y >= board_h then
    return false, x, y
  end
  return true, x, y
end

function pickup_effect(kind, config)
  if kind == "food" then
    return { score_delta = config.gameplay.food_score, grow = true, slow_add_sec = 0 }
  elseif kind == "bonus_score" then
    local bonus_score = config.gameplay.bonus_score_score or 50
    return { score_delta = bonus_score, grow = false, slow_add_sec = 0 }
  elseif kind == "bonus_slow" then
    return { score_delta = 0, grow = false, slow_add_sec = config.gameplay.slow_duration_sec }
  end
  error("unknown pickup kind: " .. tostring(kind))
end

function want_spawn_bonus(score, config, bonuses_count)
  -- пример: не спавнить, если уже есть 2 бонуса
  if bonuses_count >= 2 then return nil end
  return nil
end
```

---

## 9) Открытые вопросы (не перекрывают контракт правил)
Некоторые детали вне правил остаются на доработку и не влияют на раздел §5:
1) Кодирование `keybinds` в `config.lua` (строки/SDL keycode/SDL scancode).
2) Перечень доступных для биндинга действий (только движение или также пауза/рестарт/accept/back).
```
