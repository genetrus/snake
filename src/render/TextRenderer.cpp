#include "render/TextRenderer.h"

#include <SDL_ttf.h>

#include <algorithm>
#include <string>

namespace snake::render {
namespace {
constexpr int kGlyphW = 5;
constexpr int kGlyphH = 7;
constexpr int kGlyphSpacing = 1;

// 5x7 public domain font table for ASCII 32-127.
constexpr unsigned char kFont5x7[96][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00},  // ' '
    {0x00, 0x00, 0x5F, 0x00, 0x00},  // '!'
    {0x00, 0x07, 0x00, 0x07, 0x00},  // '"'
    {0x14, 0x7F, 0x14, 0x7F, 0x14},  // '#'
    {0x24, 0x2A, 0x7F, 0x2A, 0x12},  // '$'
    {0x23, 0x13, 0x08, 0x64, 0x62},  // '%'
    {0x36, 0x49, 0x55, 0x22, 0x50},  // '&'
    {0x00, 0x05, 0x03, 0x00, 0x00},  // '''
    {0x00, 0x1C, 0x22, 0x41, 0x00},  // '('
    {0x00, 0x41, 0x22, 0x1C, 0x00},  // ')'
    {0x14, 0x08, 0x3E, 0x08, 0x14},  // '*'
    {0x08, 0x08, 0x3E, 0x08, 0x08},  // '+'
    {0x00, 0x50, 0x30, 0x00, 0x00},  // ','
    {0x08, 0x08, 0x08, 0x08, 0x08},  // '-'
    {0x00, 0x60, 0x60, 0x00, 0x00},  // '.'
    {0x20, 0x10, 0x08, 0x04, 0x02},  // '/'
    {0x3E, 0x51, 0x49, 0x45, 0x3E},  // '0'
    {0x00, 0x42, 0x7F, 0x40, 0x00},  // '1'
    {0x42, 0x61, 0x51, 0x49, 0x46},  // '2'
    {0x21, 0x41, 0x45, 0x4B, 0x31},  // '3'
    {0x18, 0x14, 0x12, 0x7F, 0x10},  // '4'
    {0x27, 0x45, 0x45, 0x45, 0x39},  // '5'
    {0x3C, 0x4A, 0x49, 0x49, 0x30},  // '6'
    {0x01, 0x71, 0x09, 0x05, 0x03},  // '7'
    {0x36, 0x49, 0x49, 0x49, 0x36},  // '8'
    {0x06, 0x49, 0x49, 0x29, 0x1E},  // '9'
    {0x00, 0x36, 0x36, 0x00, 0x00},  // ':'
    {0x00, 0x56, 0x36, 0x00, 0x00},  // ';'
    {0x08, 0x14, 0x22, 0x41, 0x00},  // '<'
    {0x14, 0x14, 0x14, 0x14, 0x14},  // '='
    {0x00, 0x41, 0x22, 0x14, 0x08},  // '>'
    {0x02, 0x01, 0x51, 0x09, 0x06},  // '?'
    {0x32, 0x49, 0x79, 0x41, 0x3E},  // '@'
    {0x7E, 0x11, 0x11, 0x11, 0x7E},  // 'A'
    {0x7F, 0x49, 0x49, 0x49, 0x36},  // 'B'
    {0x3E, 0x41, 0x41, 0x41, 0x22},  // 'C'
    {0x7F, 0x41, 0x41, 0x22, 0x1C},  // 'D'
    {0x7F, 0x49, 0x49, 0x49, 0x41},  // 'E'
    {0x7F, 0x09, 0x09, 0x09, 0x01},  // 'F'
    {0x3E, 0x41, 0x49, 0x49, 0x7A},  // 'G'
    {0x7F, 0x08, 0x08, 0x08, 0x7F},  // 'H'
    {0x00, 0x41, 0x7F, 0x41, 0x00},  // 'I'
    {0x20, 0x40, 0x41, 0x3F, 0x01},  // 'J'
    {0x7F, 0x08, 0x14, 0x22, 0x41},  // 'K'
    {0x7F, 0x40, 0x40, 0x40, 0x40},  // 'L'
    {0x7F, 0x02, 0x0C, 0x02, 0x7F},  // 'M'
    {0x7F, 0x04, 0x08, 0x10, 0x7F},  // 'N'
    {0x3E, 0x41, 0x41, 0x41, 0x3E},  // 'O'
    {0x7F, 0x09, 0x09, 0x09, 0x06},  // 'P'
    {0x3E, 0x41, 0x51, 0x21, 0x5E},  // 'Q'
    {0x7F, 0x09, 0x19, 0x29, 0x46},  // 'R'
    {0x46, 0x49, 0x49, 0x49, 0x31},  // 'S'
    {0x01, 0x01, 0x7F, 0x01, 0x01},  // 'T'
    {0x3F, 0x40, 0x40, 0x40, 0x3F},  // 'U'
    {0x1F, 0x20, 0x40, 0x20, 0x1F},  // 'V'
    {0x7F, 0x20, 0x18, 0x20, 0x7F},  // 'W'
    {0x63, 0x14, 0x08, 0x14, 0x63},  // 'X'
    {0x03, 0x04, 0x78, 0x04, 0x03},  // 'Y'
    {0x61, 0x51, 0x49, 0x45, 0x43},  // 'Z'
    {0x00, 0x7F, 0x41, 0x41, 0x00},  // '['
    {0x02, 0x04, 0x08, 0x10, 0x20},  // '\'
    {0x00, 0x41, 0x41, 0x7F, 0x00},  // ']'
    {0x04, 0x02, 0x01, 0x02, 0x04},  // '^'
    {0x40, 0x40, 0x40, 0x40, 0x40},  // '_'
    {0x00, 0x03, 0x05, 0x00, 0x00},  // '`'
    {0x20, 0x54, 0x54, 0x54, 0x78},  // 'a'
    {0x7F, 0x48, 0x44, 0x44, 0x38},  // 'b'
    {0x38, 0x44, 0x44, 0x44, 0x20},  // 'c'
    {0x38, 0x44, 0x44, 0x48, 0x7F},  // 'd'
    {0x38, 0x54, 0x54, 0x54, 0x18},  // 'e'
    {0x08, 0x7E, 0x09, 0x01, 0x02},  // 'f'
    {0x0C, 0x52, 0x52, 0x52, 0x3E},  // 'g'
    {0x7F, 0x08, 0x04, 0x04, 0x78},  // 'h'
    {0x00, 0x44, 0x7D, 0x40, 0x00},  // 'i'
    {0x20, 0x40, 0x44, 0x3D, 0x00},  // 'j'
    {0x7F, 0x10, 0x28, 0x44, 0x00},  // 'k'
    {0x00, 0x41, 0x7F, 0x40, 0x00},  // 'l'
    {0x7C, 0x04, 0x18, 0x04, 0x78},  // 'm'
    {0x7C, 0x08, 0x04, 0x04, 0x78},  // 'n'
    {0x38, 0x44, 0x44, 0x44, 0x38},  // 'o'
    {0x7C, 0x14, 0x14, 0x14, 0x08},  // 'p'
    {0x08, 0x14, 0x14, 0x18, 0x7C},  // 'q'
    {0x7C, 0x08, 0x04, 0x04, 0x08},  // 'r'
    {0x48, 0x54, 0x54, 0x54, 0x20},  // 's'
    {0x04, 0x3F, 0x44, 0x40, 0x20},  // 't'
    {0x3C, 0x40, 0x40, 0x20, 0x7C},  // 'u'
    {0x1C, 0x20, 0x40, 0x20, 0x1C},  // 'v'
    {0x3C, 0x40, 0x30, 0x40, 0x3C},  // 'w'
    {0x44, 0x28, 0x10, 0x28, 0x44},  // 'x'
    {0x0C, 0x50, 0x50, 0x50, 0x3C},  // 'y'
    {0x44, 0x64, 0x54, 0x4C, 0x44},  // 'z'
    {0x00, 0x08, 0x36, 0x41, 0x00},  // '{'
    {0x00, 0x00, 0x7F, 0x00, 0x00},  // '|'
    {0x00, 0x41, 0x36, 0x08, 0x00},  // '}'
    {0x08, 0x08, 0x2A, 0x1C, 0x08},  // '~'
    {0x08, 0x1C, 0x2A, 0x08, 0x08},  // 127
};

int PixelScaleFromSize(int pixel_size) {
    if (pixel_size <= 0) {
        return 1;
    }
    return std::max(1, pixel_size / 8);
}
}  // namespace

bool TextRenderer::Init(const std::vector<std::filesystem::path>& font_paths, int pt_size) {
    Reset();
    font_pt_size_ = pt_size;
    ttf_ready_ = TTF_WasInit() != 0;
    if (!ttf_ready_) {
        last_error_ = "SDL_ttf not initialized";
        SDL_Log("SDL_ttf not initialized; bitmap font fallback only");
        return false;
    }

    bool loaded = false;
    for (const auto& path : font_paths) {
        font_path_ = path;
        const std::string resolved = path.string();
        SDL_Log("Attempting to load font: %s", resolved.c_str());
        if (!font_.Load(path, pt_size)) {
            last_error_ = font_.LastError();
            continue;
        }
        loaded = true;
        break;
    }

    if (!loaded && !font_paths.empty()) {
        SDL_Log("No font loaded. Last attempt: %s", font_path_.string().c_str());
        if (last_error_.empty()) {
            last_error_ = "Font file not found";
        }
    }

    return loaded;
}

void TextRenderer::Reset() {
    font_.Reset();
    ttf_ready_ = false;
    font_pt_size_ = 0;
    font_path_.clear();
    last_error_.clear();
}

bool TextRenderer::IsTtfReady() const {
    return ttf_ready_;
}

bool TextRenderer::IsFontLoaded() const {
    return font_.IsLoaded();
}

const std::filesystem::path& TextRenderer::FontPath() const {
    return font_path_;
}

const std::string& TextRenderer::LastError() const {
    return last_error_;
}

TextRenderer::Metrics TextRenderer::MeasureText(std::string_view text, int pixel_size, bool force_bitmap) const {
    if (force_bitmap || !ttf_ready_ || !font_.IsLoaded()) {
        return MeasureBitmap(text, pixel_size);
    }

    int w = 0;
    int h = 0;
    if (font_.MeasureText(text, &w, &h)) {
        return Metrics{w, h};
    }

    RecordError(font_.LastError());
    return MeasureBitmap(text, pixel_size);
}

int TextRenderer::DrawText(SDL_Renderer* r,
                           int x,
                           int y,
                           std::string_view text,
                           SDL_Color color,
                           int pixel_size,
                           bool force_bitmap) {
    if (r == nullptr) {
        return 0;
    }

    if (force_bitmap || !ttf_ready_ || !font_.IsLoaded()) {
        if (!ttf_ready_) {
            RecordError("SDL_ttf not initialized");
        } else if (!font_.IsLoaded()) {
            std::string msg = "TTF font not loaded";
            if (!font_path_.empty()) {
                msg += " (" + font_path_.string() + ")";
            }
            RecordError(msg);
        }
        return DrawBitmap(r, x, y, text, color, pixel_size);
    }

    int w = 0;
    int h = 0;
    SDL_Texture* tex = font_.RenderText(r, text, color, &w, &h);
    if (tex == nullptr) {
        RecordError(font_.LastError());
        return DrawBitmap(r, x, y, text, color, pixel_size);
    }

    SDL_Rect dst{x, y, w, h};
    SDL_RenderCopy(r, tex, nullptr, &dst);
    SDL_DestroyTexture(tex);
    return dst.h;
}

TextRenderer::Metrics TextRenderer::MeasureBitmap(std::string_view text, int pixel_size) const {
    const int scale = PixelScaleFromSize(pixel_size);
    const int char_w = (kGlyphW + kGlyphSpacing) * scale;
    const int char_h = kGlyphH * scale;
    return Metrics{static_cast<int>(text.size()) * char_w, char_h};
}

int TextRenderer::DrawBitmap(SDL_Renderer* r, int x, int y, std::string_view text, SDL_Color color, int pixel_size) const {
    const int scale = PixelScaleFromSize(pixel_size);
    const int char_w = (kGlyphW + kGlyphSpacing) * scale;
    const int char_h = kGlyphH * scale;
    SDL_SetRenderDrawColor(r, color.r, color.g, color.b, color.a);

    int cursor_x = x;
    for (char c : text) {
        unsigned char glyph = static_cast<unsigned char>(c);
        if (glyph < 32 || glyph > 127) {
            glyph = '?';
        }
        const unsigned char* cols = kFont5x7[glyph - 32];
        for (int col = 0; col < kGlyphW; ++col) {
            unsigned char bits = cols[col];
            for (int row = 0; row < kGlyphH; ++row) {
                if (bits & (1 << row)) {
                    SDL_Rect px{cursor_x + col * scale, y + row * scale, scale, scale};
                    SDL_RenderFillRect(r, &px);
                }
            }
        }
        cursor_x += char_w;
    }

    return char_h;
}

void TextRenderer::RecordError(std::string message) const {
    if (!message.empty()) {
        last_error_ = std::move(message);
    }
}

}  // namespace snake::render
